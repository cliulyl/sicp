## P396 - [练习 5.28]

修改后的[求值器在这里](./exercise_5_28.scm)，去掉了尾递归优化。

### a)

运行[练习 5.26](./exercise_5_26.md)的代码，得到迭代的阶乘，`total-pushes` 和 `maximum-depth` 的信息如下表

|  n               | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 |
|--------------    |----|----|----|----|----|----|----|----|----|----|
| maximum-depth    | 17 | 20 | 23 | 26 | 29 | 32 | 35 | 38 | 41 | 44 |
| total-pushes     | 70 | 107 | 144| 181| 218| 255| 292| 329| 366| 403|

从表格中知道 `maximum-depth` 和 `total-pushes` 都是等差数列。

```
maximum-depth = 17 + (n - 1) * 3 = 3 * n + 14
total-pushes  = 70 + (n - 1) * 37 = 37 * n + 33
```

### b)

运行[练习 5.27](./exercise_5_27.md)的代码，得到递归的阶乘，`total-pushes` 和 `maximum-depth` 的信息如下表

|  n               | 1  | 2  | 3  | 4  | 5  | 6  | 7  | 8  | 9  | 10 |
|--------------    |----|----|----|----|----|----|----|----|----|----|
| maximum-depth    | 11 | 19 | 27 | 35 | 43 | 51 | 59 | 67 | 75 | 83 |
| total-pushes     | 18 | 52 | 86| 120| 154| 188| 222| 256| 290| 324|

从表格中知道 `maximum-depth` 和 `total-pushes` 都是等差数列。

```
maximum-depth = 11 + (n - 1) * 8 = 8 * n + 3
total-pushes  = 18 + (n - 1) * 34 = 34 * n - 16
```

### c)

结合 a)、b) 的结果，没有尾递归优化时，阶乘的统计结果如下

|                           | maximum-depth  | total-pushes  | 
|---------------------------|----------------|---------------|
| 递归的阶乘(练习 5.27 的代码)  | 8 * n + 3      | 34 * n - 16   |
| 迭代的阶乘(练习 5.26 的代码)  | 3 * n + 14     | 37 * n + 33   |

对比 [练习 5.27](./exercise_5_27.md) 中的结果，原始的 `ev-sequence`，有尾递归优化时，阶乘的统计结果如下

|                           | maximum-depth  | total-pushes  | 
|---------------------------|----------------|---------------|
| 递归的阶乘(练习 5.27 的代码)  | 5 * n + 3      | 32 * n - 16   |
| 迭代的阶乘(练习 5.26 的代码)  | 10             | 35 * n + 29   |

可见，有尾递归优化时，堆栈的利用空间会有很大的改善，特别是对于迭代过程。